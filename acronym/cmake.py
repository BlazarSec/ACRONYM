import unittest
import sys
import hashlib

def dr_check(debug, release):
    return """if (CMAKE_BUILD_TYPE EQUAL "DEBUG")\n    {}\nelse()\n    {}\nendif()\n""".format(debug, release)

class Cmake():
    def __init__(self, name, c3po=True, targets={},
                 debug_flags=[f for f in "-masm=intel -Wall -Wextra -Wno-unknown-pragmas -g -O0 -fsanitize=address -fno-omit-frame-pointer".split()],
                 release_flags=[f for f in "-masm=intel -Wall -Wextra -Wno-unknown-pragmas -Ofast -s -fno-ident -march=native -flto".split()],
                 debug_defines=[], release_defines=['NDEBUG']):
        self.name = '_'.join(name.split())
        self.c3po = c3po
        self.targets = targets
        self.debug_flags = debug_flags
        self.release_flags = release_flags
        self.debug_defines = debug_defines
        self.release_defines = release_defines

    def add_target(self, name, **kwargs):
        self.targets[name] = Target(name, c3po=self.c3po, **kwargs)
        return self.targets[name]

    def __str__(self):
        return '''(
{}
targets: [
    {}
]
c3po: {}
dflags: {}
rflags: {}
ddefs: {}
rdefs: {}
)'''.format(
    self.name,
    ',\n'.join("\n    ".join(str(self.targets[t]).split('\n')) for t in self.targets),
    self.c3po,
    self.debug_flags,
    self.release_flags,
    self.debug_defines,
    self.release_defines)

    def compile(self):
        cmakelines = ["""#autogenerated by ACRONYM
#changes should be done through the utility to avoid overwrites

cmake_minimum_required(VERSION 3.9.0)
project({0})

#default to release
if(NOT CMAKE_BUILD_TYPE)
  set(CMAKE_BUILD_TYPE Release CACHE STRING "" FORCE)
endif()

#clear defaults
set(CMAKE_C_FLAGS_DEBUG "{1}")
set(CMAKE_C_FLAGS_RELEASE "{2}")

#set some standards
set(CMAKE_C_STANDARD 11)
add_definitions(-D_POSIX_C_SOURCE=200809L -D_DEFAULT_SOURCE)

#ensure IPO and LTO is avalible
set(CMAKE_POSITION_INDEPENDENT_CODE ON)
set(CMAKE_LINK_WHAT_YOU_USE ON)
include(CheckIPOSupported)
check_ipo_supported(RESULT ipo_supported OUTPUT error)
if(ipo_supported)
    set(CMAKE_INTERPROCEDURAL_OPTIMIZATION_RELEASE ON)
else()
    message(STATUS "IPO / LTO not supported: <${{error}}>")
endif()
""".format(self.name, ' '.join(self.debug_flags), ' '.join(self.release_flags))]

        if self.debug_defines:
            cmakelines.append("set(DEBUG_DEFINES {})".format(' '.join("-D{}".format(r) for r in self.debug_defines)))

        if self.release_defines:
            cmakelines.append("set(RELEASE_DEFINES {})".format(' '.join("-D{}".format(r) for r in self.release_defines)))

        cmakelines.append(dr_check("add_definitions(${DEBUG_DEFINES})",
                                    "add_definitions(${RELEASE_DEFINES})"))

        for target in self.targets:
            cmakelines.append("")
            cmakelines.append(self.targets[target].compile())

        cmakelines.append("")
        return '\n'.join(cmakelines)


class Target():
    def __init__(self, name,  c3po=True, files=[], libraries=[], includes=[], debug_flags=[], debug_defines=[], release_flags=[], release_defines=[]):
        self.name = '_'.join(name.split())
        self.c3po = c3po
        self.files = files
        self.libraries= libraries
        self.includes = includes
        self.debug_flags = debug_flags
        self.release_flags = release_flags
        self.debug_defines = debug_defines
        self.release_defines = release_defines

    def __str__(self):
        return '''(
>{}<
c3po: {}
files: {}
libs: {}
inc: {}
dflags: {}
rflags: {}
ddefs: {}
rdefs: {}
)'''.format(
    self.name,
    self.c3po,
    self.files,
    self.libraries,
    self.includes,
    self.debug_flags,
    self.release_flags,
    self.debug_defines,
    self.release_defines)

    def compile(self):
        targetlines = ["#{} specific configuration".format(self.name)]

        if not self.files:
            targetlines.append("#no files in target, skipped")
            return "\n".join(targetlines)

        targetlines.append("set({}_SOURCES\n    {})".format(self.name, '\n    '.join("\"{}\"".format(file) for file in self.files)))


        if self.c3po:
            targetlines.append("add_executable({0}d ${{{0}_SOURCES}})".format(self.name))

            targetlines.append("set(CMAKE_ENABLE_EXPORTS 1)")

            targetlines.append("set({}_GEN_SOURCES\n    {})".format(self.name, '\n    '.join("\"{}\"".format(file.replace("src/", "gen/")) for file in (self.files + ['gen/c3po.c']))))
            targetlines.append("add_executable({0} ${{{0}_GEN_SOURCES}})".format(self.name))
            targetlines.append("target_compile_definitions({} PRIVATE C3PO)".format(self.name))

            targetlines.append('add_custom_target(gen_{0} ALL COMMAND python3 "${{PROJECT_SOURCE_DIR}}/c3po/c3po.py" "build" "-s" "${{PROJECT_SOURCE_DIR}}/src" "-o" "${{PROJECT_SOURCE_DIR}}/gen")'.format(self.name))
            targetlines.append("add_dependencies(gen_{0} {0}d)".format(self.name))
            targetlines.append("add_dependencies({0} gen_{0})".format(self.name))

            targetlines.append('set_directory_properties(PROPERTY ADDITIONAL_MAKE_CLEAN_FILES "${PROJECT_SOURCE_DIR}/gen")')

            targetlines.append('add_custom_target(post_{0} ALL COMMAND python3 ${{PROJECT_SOURCE_DIR}}/c3po/c3po.py "post" "-s" "${{PROJECT_BINARY_DIR}}/{0}")'.format(self.name))
            targetlines.append("add_dependencies(post_{0} {0})".format(self.name))
        else:
            targetlines.append("add_executable({0} ${{{0}_SOURCES}})".format(self.name))

        if self.debug_flags:
            targetlines.append("set({}_DEBUG {})".format(self.name, ' '.join(self.debug_flags)))

        if self.release_flags:
            targetlines.append("set({}_RELEASE {})".format(self.name, ' '.join(self.release_flags)))

        if self.debug_defines:
            targetlines.append("set({}_DEBUG_DEFINES {})".format(self.name, ' '.join("-D{}".format(r) for r in self.debug_defines)))

        if self.release_defines:
            targetlines.append("set({}_RELEASE_DEFINES {})".format(self.name, ' '.join("-D{}".format(r) for r in self.release_defines)))

        if self.includes:
            targetlines.append("target_include_directories({} PUBLIC {})".format(self.name, ' '.join(include for include in self.includes)))

        if self.libraries:
            targetlines.append("target_link_libraries({} PRIVATE {})".format(self.name, ' '.join(library for library in self.libraries)))

        targetlines.append(dr_check("target_compile_options({0} PRIVATE ${{{0}_DEBUG}})".format(self.name),
                                    "target_compile_options({0} PRIVATE ${{{0}_RELEASE}})".format(self.name)))

        targetlines.append(dr_check("target_compile_definitions({0} PRIVATE ${{{0}_DEBUG_DEFINES}})".format(self.name),
                                    "target_compile_definitions({0} PRIVATE ${{{0}_RELEASE_DEFINES}})".format(self.name)))

        return "\n".join(targetlines)

class CmakeTest(unittest.TestCase):
    #each of the hash values was tested manually first and now unit tested to ensure it doesnt have regressions

    def test_creation(self):
        c = Cmake('test')
        self.assertEquals(c.name, 'test')

    def test_strinifya(self):
        c = Cmake('test')
        ho = hashlib.md5(str(c).encode())
        self.assertEquals(ho.hexdigest(), 'a32edd22af6277f4800c0eeda1c24a08')

    def test_strinifyb(self):
        c = Cmake('test', False)
        ho = hashlib.md5(str(c).encode())
        self.assertEquals(ho.hexdigest(), '5fc03edffe2f93bc317ad14a0071d6fc')

    def test_target_creationa(self):
        c = Cmake('test')
        c.add_target('main')
        self.assertTrue(len(c.targets) > 0)

    def test_target_creationb(self):
        t = Target('main')
        self.assertEquals(t.name, 'main')

    def test_target_strinifya(self):
        c = Cmake('test')
        c.add_target('main')
        ho = hashlib.md5(str(c).encode())
        self.assertEquals(ho.hexdigest(), 'a32edd22af6277f4800c0eeda1c24a08')

    def test_target_strinifyb(self):
        c = Cmake('test', False)
        c.add_target('main')
        ho = hashlib.md5(str(c).encode())
        self.assertEquals(ho.hexdigest(), 'b4029a3e960e40c82b3cbdc95c5f5fa3')

    def test_basic_compile(self):
        c = Cmake('test')
        ho = hashlib.md5(c.compile().encode())
        self.assertEquals(ho.hexdigest(), '08d84cfabc29aa07ab0affe711fb5967')

    def test_basic_target_compile(self):
        c = Cmake('test')
        c.add_target('main')
        ho = hashlib.md5(c.compile().encode())
        self.assertEquals(ho.hexdigest(), '27f081506208be43c39c296885f5617e')

    def test_adv_target_compile(self):
        c = Cmake('test', False)
        t = c.add_target('main')
        t.files.append('src/main.c')
        ho = hashlib.md5(c.compile().encode())
        self.assertEquals(ho.hexdigest(), '08d84cfabc29aa07ab0affe711fb5967')
