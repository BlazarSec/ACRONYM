#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import subprocess
import logging
from logging import iprint, eprint, dprint, wprint

def contains_end(value, endings):
    for end in endings:
        if value.endswith(end):
            return True
    return False

maintemplate = """#autogenerated by ACRONYM, changes may be overwritten
cmake_minimum_required (VERSION 3.0)
project ({0})

set ({0}_VERSION_MAJOR 1)
set ({0}_VERSION_MINOR 0)

if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Release)
endif()


set(CMAKE_C_FLAGS "-Wall -Wextra")
set(CMAKE_C_FLAGS_DEBUG "-g -O0 -fsanitize=address -fno-omit-frame-pointer")
set(CMAKE_C_FLAGS_RELEASE "-Ofast -s -fno-ident  -march=native -flto -DNDEBUG")

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_C_STANDARD 11)

set(CMAKE_MODULE_PATH ${{CMAKE_MODULE_PATH}} "${{CMAKE_CURRENT_LIST_DIR}}")

add_definitions(-D_POSIX_C_SOURCE=200809L)
add_definitions(-D_DEFAULT_SOURCE)

include_directories({1})

set(THREADS_PREFER_PTHREAD_FLAG ON)
find_package(Threads REQUIRED)

{2}

SET(COMMON_SOURCES
    {4}
    )

{3}
"""

targettemplate = """
#{0} target
SET(SOURCES_{0}
    "src/{0}.c"
    )

add_executable({0} ${{COMMON_SOURCES}} SOURCES_{0})

if (CMAKE_BUILD_TYPE EQUAL Release)
    set_target_properties({0} PROPERTIES INTERPROCEDURAL_OPTIMIZATION TRUE POSITION_INDEPENDENT_CODE TRUE)
endif()

target_link_libraries({0} rt Threads::Threads)
"""
simpletargettemplate = """
#{0} target
add_executable({0} ${{COMMON_SOURCES}})

if (CMAKE_BUILD_TYPE EQUAL Release)
    set_target_properties({0} PROPERTIES INTERPROCEDURAL_OPTIMIZATION TRUE POSITION_INDEPENDENT_CODE TRUE)
endif()

target_link_libraries({0} rt Threads::Threads)

"""


def build_cmakelists(src_path, include_dirs, project_name, targets=[], constants=[], endings=[".c"]):
    src_files = [f for f in os.listdir(src_path) if os.path.isfile(os.path.join(src_path,f)) and contains_end(f,endings)]

    if len(targets) > 0:
        #remove the files that are containing the mains for the additional targets
        for file in src_files:
            for target in targets:
                if file.startswith(target):
                    src_files.remove(file)
                    #TODO track which file is removed to support more than just c
                    #also check to make sure its just the name + the ending

    src_str = "    \n".join("\"src/" + f + "\"" for f in src_files)

    include_str = "src"

    if len(include_dirs) > 0:
        include_str += " " + " ".join(include_dirs)

    targetstr = "\n".join(targettemplate.format(t) for t in targets) if len(targets) > 0 else simpletargettemplate.format(project_name)

    definitionstr = "add_definitions({})".format(" ".join("-D{}".format(s) for s in constants)) if len(constants) > 0 else ""

    return maintemplate.format(project_name,
                               include_str,
                               definitionstr,
                               targetstr,
                               src_str)



def scaffold_skeleton(path, project_name, cmakelists=None, git_init=True, folder_init=True, cmake=True, helloworld=True):
    #handle people creating a folder for the name of their project before calling the tool
    iprint("using fullpath {}".format(path))

    if not os.path.exists(path):
        iprint("creating folder {}".format(path))
        try:
            os.mkdir(path)
        except OSError:
            eprint("failed to create folder")
            return
    elif not os.path.isdir(path):
        iprint("path is taken by a non folder")
    else:
        wprint("folder already exists")

    if folder_init:
        bin_path = os.path.join(path, "bin")
        src_path = os.path.join(path, "src")
        deps_path = os.path.join(path, "deps")
        if os.path.exists(bin_path):
            wprint("{} already exists".format(bin_path))
        else:
            iprint("creating folder {}".format(bin_path))
            try:
                os.mkdir(bin_path)
            except OSError:
                eprint("failed to create folder")
                return

        if os.path.exists(src_path):
            wprint("{} already exists".format(src_path))
        else:
            iprint("creating folder {}".format(src_path))
            try:
                os.mkdir(src_path)
            except OSError:
                eprint("failed to create folder")
                return

        if os.path.exists(deps_path):
            wprint("{} already exists".format(deps_path))
        else:
            iprint("creating folder {}".format(deps_path))
            try:
                os.mkdir(deps_path)
            except OSError:
                eprint("failed to create folder")
                return

    if helloworld:
        main_path = os.path.join(path, "src", "main.c")
        if os.path.exists(main_path):
            wprint("{} already exists".format(main_path))
        else:
            iprint("creating file {}".format(main_path))
            with open(main_path, "w") as f:
                f.write("""#include <stdio.h>
int main(void) {
   puts("hello world");
   return 0;
}
""")

    if git_init:
        gitignore_path = os.path.join(path, ".gitignore")
        git_path = os.path.join(path, ".git")
        if os.path.exists(gitignore_path):
            wprint("{} already exists".format(gitignore_path))
        else:
            iprint("creating file {}".format(gitignore_path))
            with open(gitignore_path, "w") as f:
                f.write("bin/")
        if os.path.exists(git_path):
            wprint("{} already exists".format(git_path))
        else:
            logging.reset_print()
            subprocess.call(['git', 'init', path])

    cmake_path = os.path.join(path, "CMakeLists.txt")
    #call the cmake generator last
    if os.path.exists(cmake_path):
        wprint("{} already exists".format(cmake_path))
    else:
        iprint("creating file {}".format(cmake_path))
        if not cmakelists:
            cmakelists = build_cmakelists(src_path, [], project_name)
        with open(cmake_path, "w") as f:
            f.write(cmakelists)


if __name__ == "__main__":
    #if you want to run this directly make sure to run it from the root of the repo
    #./src/skeleton.py /path/for/code
    if len(sys.argv) != 3:
        eprint("Please specify a path and a name")
        sys.exit(1)
    scaffold_skeleton(sys.argv[1], sys.argv[2])


